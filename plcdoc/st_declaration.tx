// Process complete declaration
Declaration:
    typedefs*=TypeDef
    (function=Function)?
    properties*=Property
    CommentIgnored*
;

Fqn: (ID '.')? ID;

TypeDef:
    CommentIgnored*
    attributes*=Attribute
    CommentLineIgnored*
    comment=CommentBlock?
    'TYPE' name=ID ('EXTENDS' extends=ID)? ':'
    (type=TypeStruct | type=TypeEnum)
    CommentIgnored*
    'END_TYPE'
;

TypeStruct:
    'STRUCT'
    properties*=Variable
    'END_STRUCT'
;

TypeEnum:
    '('
    values*=EnumOption[',']
    ')' base_type=ID? ';'
;

EnumOption:
    CommentIgnored*
    name=ID
    (':=' number=INT)?
    CommentIgnored*
;

Function:
    CommentLineIgnored*
    comment=CommentBlock?
    attributes*=Attribute
    function_type=FunctionType (visibility=Visibility)? name=ID ('EXTENDS' extends=Fqn)? (':' return=ID)? CommentIgnored?
    CommentIgnored*
    lists*=VariableList
;

FunctionType:
    'FUNCTION_BLOCK' | 'FUNCTION' | 'METHOD' | 'PROGRAM'
;

Visibility:
    'PUBLIC' | 'PRIVATE'
;

Program:
    'PROGRAM' name=ID
    lists*=VariableList
    CommentIgnored*
;

Attribute :
    '{' ID attribute=STRING (':=' value=STRING)? '}' /\s*/
    // The extra match of whitespace is need to prevent issues with a following comment
;

VariableList:
    CommentIgnored*
    attributes*=Attribute
    name=VariableListType (modifiers='CONSTANT')? CommentIgnored?
    variables*=Variable
    'END_VAR'
;

VariableListType:
    (/VAR_\w+/ | 'VAR')
;

// A single variable definition
Variable:
    CommentIgnored*
    attribute=Attribute?
    CommentIgnored*
    name=ID (address=VariableAddress)? ':' type=VariableType value=VariableValue? ';' comment=CommentDescription?
    CommentIgnored*
    attribute=Attribute?
    CommentIgnored*
;

VariableType:
    VariableTypeArray | VariableTypeString | ID+
;

VariableTypeArray:
    'ARRAY' '[' range=ArrayRange ']' 'OF' type=ID
;

VariableTypeString:
    ('STRING[' INT ']') | ('STRING(' INT ')')
;

ArrayRange:
    //(INT '..' INT|Fqn) | ('*')
    /[\w\.\s\*\-\+]+/
;

VariableAddress:
    'AT' '%' /[A-Z%\.\*]/+
;

// Variable initial value
VariableValue:
    ':=' value=Literal
;

// Catch literals for initialization
Literal:
    STRICTFLOAT|STRING|StructInit|Anything
    // QualifiedName?
;

StructInit:
    '('
    (ID ':=' Literal)*[',']
    ')'
;

QualifiedName:
    (ID '.')* ID
;

Anything:
    /[\w#\.]+/
;

Property:
    attributes*=Attribute
    'PROPERTY' visibility=Visibility name=ID ':' VariableType
;

// The `Comment` clause is reserved, create a custom clause that won't be removed automatically

CommentLineIgnored: /\/\/.*$/;
CommentBlockIgnored: /\s*\(\*(.|\n)*?\*\)\s*/;

CommentIgnored:
    CommentLineIgnored | CommentBlockIgnored
;

// Built-in `Comment` - use to remove any line and block comments that remain in the end
//Comment:
//    CommentIgnored | CommentBlockIgnored
//;

CommentDescription:
    '//' comment=/.*$/
;

CommentBlock[noskipws]:
    /\s*/- comment=/\(\*(.|\n)*?\*\)/
    // Use the non-greedy repetition `*?`
    // Search for leading/trailing whitespace (helps with adjoining commands), but unmatch them again from the result
;
