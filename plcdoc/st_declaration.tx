/*
Parse the StructuredText declaration specifically.

In practice all segments are in different XML leaves, but the syntax would allow for combinations. We pretend everything
could be in a big file.

Note: `FUNCTION*` does not have a closing call for some reason!

There are a lot of `comments*=CommentAny`. This will offer a list of comments, the relevant docblocks need to be
extracted later. There seems no better way to do this in TextX.
Comment captures should be move down (= more basic elements) as much as possible to limit their usage.
*/
Declaration:
    types*=TypeDef
    properties*=Property
    functions*=Function
    CommentAny*
;

/*
---------------------------------------------------
*/
/*
One instance of an ENUM or STRUCTURE
*/
TypeDef:
    comments*=CommentAny
    'TYPE'
    name=ID
    ('EXTENDS' extends=Fqn)?
    ':'
    (type=TypeStruct | type=TypeEnum)
    CommentAny*
    'END_TYPE'
;

TypeStruct:
    'STRUCT'
    properties*=Variable
    CommentAny*
    // Catch trailing comments here, not at the end of `Variable`
    'END_STRUCT'
;

TypeEnum:
    '('
    values*=EnumOption
    CommentAny*
    ')'
    (base_type=Fqn)?
    ';'
;

EnumOption:
    CommentAny*
    name=ID
    (':=' number=INT)?
    (',')?
    (comment=CommentLine)?
;

/*
---------------------------------------------------
*/
/*
One instance of a FUNCTION, FUNCTION_BLOCK, METHOD, ...
*/
Function:
    comments*=CommentAny
    function_type=FunctionType
    (abstract?='ABSTRACT')
    (final?='FINAL')
    (visibility=Visibility)?
    name=ID
    ('EXTENDS' extends=Fqn)?
    ('IMPLEMENTS' implements=Fqn)?
    (':' return=Fqn)?
    lists*=VariableList
;

FunctionType:
    'FUNCTION_BLOCK' | 'FUNCTION' | 'METHOD' | 'PROGRAM'
;

Visibility:
    'PUBLIC' | 'PRIVATE' | 'PROTECTED' | 'INTERNAL'
;

/*
---------------------------------------------------
*/

Property:
    'PROPERTY'
    (visibility=Visibility)?
    name=ID
    ':'
    type=VariableType
;

/*
---------------------------------------------------
*/
/*
Variable declarations. There are many different notations, so this is tricky.
*/

VariableList:
    CommentAny*
    name=VariableListType
    (constant?='CONSTANT')?
    variables*=Variable
    CommentAny*
    // Catch trailing comments here, not at the end of `Variable`
    'END_VAR'
;

VariableListType:
    /VAR_\w+/ | 'VAR'
;

/*
Single variable declaration
*/
Variable:
    CommentAny*
    name=ID
    (address=Address)?
    ':'
    type=VariableType
    (arglist=ArgList)?
    (':=' value=AssignmentValue)?
    ';'
    comment=CommentLine?
;

VariableType:
    (array=VariableTypeArray)?
    (pointer=PointerLike 'TO')?
    name=Fqn
;

PointerLike:
    'POINTER' | 'REFERENCE'
;

VariableTypeArray:
    'ARRAY'- '['- ArrayRange ']'- 'OF'-
;

ArrayRange:
    ((Value '.' '.' Value)+[',']) | ('*'+[','])
;

AssignmentValue:
    ArgList | Value
;

ArgList:
    ('(' fields*=Arg[','] ')') | ('[' fields*=Arg[','] ']')
    // Match both `(..)` and `[...]` but brackets must match!
;

Arg:
    (name=ID ':=')? value=Value
;

Address:
    'AT' '%' /[A-Z%\.\*]/+
;

/*
Any variable name basically (do not skip whitespace because we don't want to match "first. second")
*/
Fqn[noskipws]:
    /\s/*-
    ID('.'ID)*
    /\s/*-
;

/*
Single value, either a literal (69, 420.0, 'text') or another variable ("idx", "X.Y")
*/
Value:
    STRING | NumericHashtags | NumericUnderscores | NUMBER | Fqn
;

Arithmetic:
    /[\-\+\*\/]/
;

/*
Match the hashtag-based literals for integers and time
*/
NumericHashtags[noskipws]:
    /\s/*-
    /\w+(#\w+)?#\w+/
    /\s/*-
;

/*
Match numbers with underscores
*/
NumericUnderscores[noskipws]:
    /\s/*-
    /\d+_\d+(\d|_)+/
    /\s/*-
;

/*
---------------------------------------------------
*/

/*
The `Comment` clause is reserved, which removes comments but then we cannot process them.

We also put `Attribute` in the comment pile, because it can be placed just about everywhere

A named field is added for comments so we can easily distinguish between comment lines and blocks.
*/

CommentAny:
    CommentLine | CommentBlock | Attribute
;

CommentLine:
    '//'- text=/.*$/
;

CommentBlock[noskipws]:
    /\s*/- text=/\(\*(.|\n)*?\*\)/ /\s*/-
    // Use the non-greedy repetition `*?`
;

Attribute:
    '{'
    field=ID
    name=STRING
    (':=' value=STRING)?
    '}'
;

//Comment:
//    CommentAny
//;
