/*
Parse the StructuredText declaration specifically.

In practice all segments are in different XML leaves, but the syntax would allow for combinations. We pretend everything
could be in a big file.

Note: `FUNCTION*` does not have a closing call for some reason!

There are a lot of `comments*=CommentAny`. This will offer a list of comments, the relevant docblocks need to be
extracted later. There seems no better way to do this in TextX.
Comment captures should be move down (= more basic elements) as much as possible to limit their usage.

There can be dynamic expressions in variable declarations, which are very tricky to parse. Therefore expected
expressions are parsed greedily as whole string. As a consequence, blocks like argument lists will result in a long
string including the parentheses and commas.
*/
Declaration:
    types*=TypeDef
    properties*=Property
    functions*=Function
    CommentAny*
;

/*
---------------------------------------------------
*/
/*
One instance of an ENUM or STRUCTURE
*/
TypeDef:
    comments*=CommentAny
    'TYPE'
    name=ID
    ('EXTENDS' extends=Fqn)?
    ':'
    (type=TypeStruct | type=TypeEnum)
    CommentAny*
    'END_TYPE'
;

TypeStruct:
    'STRUCT'
    properties*=Variable
    CommentAny*
    // Catch trailing comments here, not at the end of `Variable`
    'END_STRUCT'
;

TypeEnum:
    '('
    values*=EnumOption
    CommentAny*
    ')'
    (base_type=Fqn)?
    ';'
;

EnumOption:
    CommentAny*
    name=ID
    (':=' number=INT)?
    (',')?
    (comment=CommentLine)?
;

/*
---------------------------------------------------
*/
/*
One instance of a FUNCTION, FUNCTION_BLOCK, METHOD, ...
*/
Function:
    comments*=CommentAny
    function_type=FunctionType
    (abstract?='ABSTRACT')
    (final?='FINAL')
    (visibility=Visibility)?
    name=ID
    ('EXTENDS' extends=Fqn)?
    ('IMPLEMENTS' implements=Fqn)?
    (':' return=Fqn)?
    lists*=VariableList
;

FunctionType:
    'FUNCTION_BLOCK' | 'FUNCTION' | 'METHOD' | 'PROGRAM'
;

Visibility:
    'PUBLIC' | 'PRIVATE' | 'PROTECTED' | 'INTERNAL'
;

/*
---------------------------------------------------
*/

Property:
    'PROPERTY'
    (visibility=Visibility)?
    name=ID
    ':'
    type=VariableType
;

/*
---------------------------------------------------
*/
/*
Variable declarations. There are many different notations, so this is tricky.
*/

VariableList:
    CommentAny*
    name=VariableListType
    (constant?='CONSTANT')?
    variables*=Variable
    CommentAny*
    // Catch trailing comments here, not at the end of `Variable`
    'END_VAR'
;

VariableListType:
    /VAR_\w+/ | 'VAR'
;

/*
Single variable declaration
*/
Variable:
    CommentAny*
    name=ID
    (address=Address)?
    ':'
    type=VariableType
    (arglist=ArgList)?
    (':=' value=AssignmentValue)?
    ';'
    comment=CommentLine?
;

VariableType:
    (array=VariableTypeArray)?
    (pointer=PointerLike 'TO')?
    name=Fqn
;

PointerLike:
    'POINTER' | 'REFERENCE'
;

VariableTypeArray:
    'ARRAY'- ArrayRange 'OF'-
;

ArrayRange:
    '['-
    /[^\]]+/
    ']'-
    // Match anything except the square bracket at the end
;

AssignmentValue:
    ArgList | Expression
;

ArgList:
    ( '(' | '[' )
    /[^;]*/
    // Match anything, including parentheses, up to (but excluding) the semicolon
;

Address:
    'AT' '%' /[A-Z%\.\*]/+
;

/*
Any variable name basically (do not skip whitespace because we don't want to match "first. second")
*/
Fqn[noskipws]:
    /\s/*-
    ID('.'ID)*
    /\s/*-
;

/*
Anything that is considered a value: a literal, a variable, or e.g. a sum
*/
Expression:
    /[^;]*/
    // Match anything, including parentheses, up to (but excluding) the semicolon
;

/*
---------------------------------------------------
*/

/*
The `Comment` clause is reserved, which removes comments but then we cannot process them.

We also put `Attribute` in the comment pile, because it can be placed just about everywhere

A named field is added for comments so we can easily distinguish between comment lines and blocks.
*/

CommentAny:
    CommentLine | CommentBlock | Attribute
;

CommentLine:
    '//'- text=/.*$/
;

CommentBlock[noskipws]:
    /\s*/- text=/\(\*(.|\n)*?\*\)/ /\s*/-
    // Use the non-greedy repetition `*?`
;

Attribute:
    '{'
    field=ID
    name=STRING
    (':=' value=STRING)?
    '}'
;

//Comment:
//    CommentAny
//;
