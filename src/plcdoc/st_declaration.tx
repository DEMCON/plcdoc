/*
Parse the StructuredText declaration specifically.

In practice all segments are in different XML leaves, but the syntax would allow for combinations. We pretend everything
could be in a big file.

Note: `FUNCTION*` does not have a closing call for some reason!

There are a lot of `comments*=CommentAny`. This will offer a list of comments, the relevant docblocks need to be
extracted later. There seems no better way to do this in TextX.
Comment captures should be move down (= more basic elements) as much as possible to limit their usage.

There can be dynamic expressions in variable declarations, which are very tricky to parse. Therefore expected
expressions are parsed greedily as whole string. As a consequence, blocks like argument lists will result in a long
string including the parentheses and commas.
*/
Declaration:
    types*=TypeDef
    properties*=Property
    functions*=Function
    variable_lists*=VariableList
    CommentAny*
;

/*
---------------------------------------------------
*/
/*
One instance of an ENUM or STRUCTURE
*/
TypeDef:
    comments*=CommentAny
    'TYPE'
    name=ID
    ('EXTENDS' extends=Fqn)?
    ':'
    CommentAny*
    type=AnyType
    CommentAny*
    'END_TYPE'
;

AnyType:
    TypeStruct | TypeUnion | TypeEnum
;

TypeStruct:
    'STRUCT'
    members*=Variable
    CommentAny*
    // Catch trailing comments here, not at the end of `Variable`
    'END_STRUCT'
;

TypeUnion:
    'UNION'
    members*=Variable
    CommentAny*
    // Catch trailing comments here, not at the end of `Variable`
    'END_UNION'
;

TypeEnum:
    '('
    values*=EnumOption
    CommentAny*
    ')'
    (base_type=Fqn)?
    ';'
;

EnumOption:
    CommentAny*
    name=ID
    (':=' number=INT)?
    (',')?
    (comment=CommentLine)?
;

/*
---------------------------------------------------
*/
/*
One instance of a FUNCTION, FUNCTION_BLOCK, METHOD, ...
*/
Function:
    comments*=CommentAny
    function_type=FunctionType
    (abstract?='ABSTRACT' final?='FINAL' (visibility=Visibility)?)#
    name=ID
    ('EXTENDS' extends=Fqn)?
    ('IMPLEMENTS' implements=Fqn)?
    (':' return=VariableType)?
    (';')?
    lists*=VariableList
;

FunctionType:
    'FUNCTION_BLOCK' | 'FUNCTION' | 'INTERFACE' | 'METHOD' | 'PROGRAM'
;

Visibility:
    'PUBLIC' | 'PRIVATE' | 'PROTECTED' | 'INTERNAL'
;

/*
---------------------------------------------------
*/

Property:
    comments*=CommentAny
    'PROPERTY'
    (visibility=Visibility)?
    name=ID
    ':'
    type=VariableType
;

/*
---------------------------------------------------
*/
/*
Variable declarations. There are many different notations, so this is tricky.
*/

VariableList:
    CommentAny*
    name=VariableListType
    (constant?='CONSTANT')?
    (persistent?='PERSISTENT')?
    variables*=Variable
    CommentAny*
    // Catch trailing comments here, not at the end of `Variable`
    'END_VAR'
;

VariableListType:
    /VAR_\w+/ | 'VAR'
;

/*
Single variable declaration

Unfortunately, it is possible to define multiple variables inline - those are ignored for now
*/
Variable:
    CommentAny*
    name=ID
    (',' ID)*
    (address=Address)?
    ':'
    type=VariableType
    (AssignmentSymbol value=Expression)?
    ';'
    comment=CommentLine?
;

AssignmentSymbol:
    (':=') | ('REF=')
;

VariableType:
    (array=VariableTypeArray)?
    (pointer=PointerLike 'TO')?
    name=BaseType
;

BaseType:
    StringType | Fqn
    (CallSuffix)?
;

CallSuffix: '(' AnyArguments? ')';

StringType: 'STRING' StringSize;
StringSize:
    '[' Expression ']'
    | '(' Expression ')'
;

PointerLike:
    'POINTER' | 'REFERENCE'
;

VariableTypeArray:
    'ARRAY'- '['- dimensions+=ArrayDimension[','] ']'- 'OF'-
;

ArrayDimension:
    Expression '..' Expression
    | '*'
;

Address:
    'AT' '%' /[A-Z%\.\*]/+
;

/*
Any variable name basically (do not skip whitespace because we don't want to match "first. second")
*/
Fqn[noskipws]:
    /\s/*-
    ID('.'ID)*
    /\s/*-
;

AnyArguments: Range | LabeledArguments | Arguments;
Range: Expression '..' Expression;
Arguments: arguments*=Expression[','];
LabeledArguments: arguments*=LabeledArgument[','];
LabeledArgument: ID ':=' Expression;

Expression: Factor (AddOp Factor)*;
AddOp: '+' | '-' ;
Factor: Primary (MulOp Primary)*;
MulOp: '*' | '/';

Primary:
    Literal
    | FunctionCall
    | Atom
    | '(' Expression ')'
;

FunctionCall:
    Fqn CallSuffix
;

Atom: Fqn Index*;
Index: '[' Expression ']';

Literal: StringLiteral
       | StructLiteral
       | BinaryLiteral
       | OctalLiteral
       | DecaLiteral
       | 'UDINT#'? HexLiteral
       | TimeLiteral
       | FLOAT
       | IntegerLiteral
;

BinaryLiteral: /2#[01_]+/;
OctalLiteral: /8#[0-7_]+/;
DecaLiteral: /10#[0-9_]+/;
HexLiteral: /16#[0-9a-fA-F_]+/;
TimeLiteral: /T#[0-9hHmMsS]+/;
IntegerLiteral: /[0-9][0-9_]*/;
StringLiteral: /'.*?'/;
StructLiteral: '(' fields+=StructLiteralItem[','] ')';
StructLiteralItem: ID ':=' Expression;

/*
---------------------------------------------------
*/

/*
The `Comment` clause is reserved, which removes comments but then we cannot process them.

We also put `Attribute` in the comment pile, because it can be placed just about everywhere

A named field is added for comments so we can easily distinguish between comment lines and blocks.
*/

CommentAny:
    CommentLine | CommentBlock | Attribute
;

CommentLine:
    '//'- text=/.*$/
;

CommentBlock[noskipws]:
    /\s*/- text=/\(\*(.|\n)*?\*\)/ /\s*/-
    // Use the non-greedy repetition `*?`
;

/*
The attribute comment is nasty because there are basically no rules - hence just do a wildcard match
*/
Attribute:
    '{'
    field=ID
    (name=STRING)?
    (content=/[^}]+/)?
    '}'
;

//Comment:
//    CommentAny
//;
